<!doctype html>
<html lang="it">
<head>
<script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
<script src="https://unpkg.com/upng-js@2.1.0/UPNG.js"></script>
  
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Doodles GIF Lab — Minimal (single viewer + stable GIF)</title>
<link rel="icon" href="data:,">
<style>
  :root{--bg:#0f1115;--card:#171a21;--text:#eef2ff;--muted:#9aa3b2;--border:#232938;--ok:#67e8f9}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{max-width:980px;margin:20px auto;padding:0 16px;display:grid;gap:14px}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px}
  h1{margin:0 0 6px;font-size:18px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{color:var(--muted)}
  input[type="number"],button{background:#0c0e13;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px 10px}
  button{cursor:pointer}
  button.primary{border-color:var(--ok);color:var(--ok)}
  /* Stage = UNICO visualizzatore */
  #stageWrap{position:relative;border:1px dashed var(--border);border-radius:14px;overflow:hidden;background:#fff}
  #stage{position:relative;margin:auto}
  #view{display:block}
  /* lottie container OFF-SCREEN (usato solo per generare lo SVG) */
  #lottieOff { position:absolute; left:-99999px; top:-99999px; width:1px; height:1px; overflow:hidden; }
</style>

<!-- Lottie -->
<script src="https://unpkg.com/lottie-web/build/player/lottie.min.js"></script>
<!-- GIF encoder -->
<script src="https://unpkg.com/gif.js.optimized/dist/gif.js"></script>
</head>
<body>
<div class="wrap">
  <h1>Doodles GIF Lab — Minimal</h1>

  <div class="panel">
    <div class="row">
      <label for="doodleId">ID Doodle:</label>
      <input type="number" id="doodleId" placeholder="es. 0" min="0" style="width:120px">
      <button id="btnCompose" class="primary">Fetch &amp; Compose</button>
      <button id="btnExportWebM">Export WebM 3s</button>
      <button id="btnExportGIF">Export GIF 3s</button>
      <button id="btnExportAPNG">Export APNG 3s</button>
      <label>&nbsp;Size GIF:</label>
      <select id="gifSize">
        <option value="900" selected>900px</option>
        <option value="720">720px</option>
        <option value="600">600px</option>
        <option value="512">512px</option>
      </select>
      <label>FPS:</label>
      <select id="gifFps"><option>12</option><option >15</option><option>20</option><option selected>30</option></select>
    </div>
  </div>

  <div class="panel">
    <div id="stageWrap">
      <div id="stage">
        <!-- MASTER canvas 1800x1800 per export -->
        <canvas id="compBase" width="1800" height="1800" style="display:none"></canvas>
        <!-- UNICO viewer -->
        <canvas id="view"></canvas>
      </div>
    </div>
  </div>

  <!-- Lottie viene renderizzata qui ma non è visibile -->
  <div id="lottieOff"></div>
</div>

<script>
/* ============ Utils/IPFS ============ */
const IPFS_GATEWAYS = [
  'https://ipfs.io/ipfs/','https://dweb.link/ipfs/','https://cf-ipfs.com/ipfs/',
  'https://gateway.pinata.cloud/ipfs/','https://nftstorage.link/ipfs/'
];
const sleep = ms => new Promise(r=>setTimeout(r,ms));
async function fetchWithTimeout(url,{timeout=8000,...opts}={}){ const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort('timeout'),timeout); try{ return await fetch(url,{...opts,signal:ctrl.signal}); } finally{ clearTimeout(t); } }
async function fetchWithFallback(urls,{timeout=8000,...opts}={}){ let last=null; for(const u of urls){ try{ const r=await fetchWithTimeout(u,{timeout,...opts}); if(r.ok) return r; last=new Error('HTTP '+r.status);}catch(e){ last=e;} } throw last||new Error('All gateways failed'); }
function ipfsToHttpFallbacks(ipfsUrl){ if(!ipfsUrl) return []; const path = ipfsUrl.startsWith('ipfs://') ? ipfsUrl.slice(7) : ipfsUrl; const cb='?cb='+Date.now().toString(36); return IPFS_GATEWAYS.map(g=>g+path+cb); }

/* ============ CSV colori ============ */
function parseColorCsv(text){
  const lines=text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const map=new Map(); const norm=s=>String(s).trim().toLowerCase();
  for(const raw of lines){
    const useSemi=raw.split(';').length>raw.split(',').length;
    const parts=raw.split(useSemi?';':','); if(parts.length<2) continue;
    const name=parts.shift(); const hex=parts.join(useSemi?';':',');
    if(!name||!hex) continue;
    map.set(norm(name), hex.includes('|')?hex.split('|').map(s=>s.trim()):hex.trim());
  }
  return { getStops(name){ const v=map.get(norm(name)); if(!v) throw new Error('Colore non trovato: '+name); return Array.isArray(v)?v:[v]; } };
}

/* ============ Lottie (off-screen) ============ */
const LAYER_SKIN='Skin_fill',LAYER_SLEEVE='Sleeve_fill',LAYER_SHADOW='Shadow_fill';
let anim=null, svgEl=null, lottieData=null;
function tagAllLayersWithNames(animation){
  const tag=(el)=>{ const name=el?.data?.nm; const dom=el?.layerElement||el?.baseElement||el?.parentContainer||null;
    if(name&&dom?.setAttribute) dom.setAttribute('data-name',name);
    if(el?.elements?.length) el.elements.forEach(tag);
  };
  (animation?.renderer?.elements||[]).forEach(tag);
}
function getLayerRoots(svg,name){ return [...svg.querySelectorAll(`[data-name="${name}"]`)]; }
function getLayerShapesByName(svg,name){ const roots=getLayerRoots(svg,name), set=new Set(); roots.forEach(r=>{ r.querySelectorAll('path,polygon,rect,circle,ellipse,use,g').forEach(n=>set.add(n)); }); return [...set]; }
function forceFill(node,val){ node.setAttribute('fill',val); node.style.setProperty('fill',val,'important'); }
function ensureDefs(svg){ let d=svg.querySelector('defs'); if(!d){ d=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.prepend(d);} return d; }
function injectLinearGradient(svg,id,stops,attrs){ const defs=ensureDefs(svg), lg=document.createElementNS('http://www.w3.org/2000/svg','linearGradient'); lg.setAttribute('id',id); Object.entries(attrs).forEach(([k,v])=>lg.setAttribute(k,v)); stops.forEach(s=>{ const st=document.createElementNS('http://www.w3.org/2000/svg','stop'); st.setAttribute('offset',s.offset); st.setAttribute('stop-color',s.color); if(s.opacity!=null) st.setAttribute('stop-opacity',s.opacity); lg.appendChild(st); }); defs.appendChild(lg); return id; }
function setLayerFlatByName(svg,name,color){ getLayerShapesByName(svg,name).forEach(n=>forceFill(n,color)); }
function setLayerGradientStopsByName(svg,name,hexList,orientation='horizontal'){
  const id=`grad_${name}_${Date.now()}`, n=hexList.length;
  const stops=hexList.map((c,i)=>({offset:(n===1?0:(i/(n-1)))*100+'%',color:c}));
  const attrs=orientation==='horizontal'?{x1:'0%',y1:'0%',x2:'100%',y2:'0%'}:{x1:'0%',y1:'0%',x2:'0%',y2:'100%'};
  injectLinearGradient(svg,id,stops,attrs);
  getLayerShapesByName(svg,name).forEach(n=>forceFill(n,`url(#${id})`));
}
function setSoftLightByName(svg,name,opacity=.8){ getLayerRoots(svg,name).forEach(r=>{ r.style.mixBlendMode='soft-light'; r.style.opacity=String(opacity); }); }
async function loadAnimFromJson(json){
  lottieData=json;
  if(anim){ try{anim.destroy();}catch{} }
  anim=lottie.loadAnimation({container:document.getElementById('lottieOff'),renderer:'svg',loop:true,autoplay:true,animationData:lottieData});
  anim.addEventListener('DOMLoaded',()=>{
    svgEl=anim.renderer.svgElement;
    svgEl.setAttribute('viewBox','0 0 1800 1800');
    svgEl.setAttribute('preserveAspectRatio','xMidYMid meet');
    tagAllLayersWithNames(anim);
    setSoftLightByName(svgEl,LAYER_SHADOW,0.8);
  });
}

/* ============ Knockout ============ */
function toGray(imgData){const{data,width,height}=imgData;const gray=new Uint8Array(width*height);
  for(let i=0,j=0;i<data.length;i+=4,j++){const r=data[i],g=data[i+1],b=data[i+2];gray[j]=Math.min(255,(0.299*r+0.587*g+0.114*b)|0);}return gray;}
function otsu(gray){const hist=new Float64Array(256);for(let i=0;i<gray.length;i++)hist[gray[i]]++;const total=gray.length;let sum=0;for(let t=0;t<256;t++)sum+=t*hist[t];
  let sumB=0,wB=0,varMax=0,thr=96;for(let t=0;t<256;t++){wB+=hist[t];if(wB===0)continue;const wF=total-wB;if(wF===0)break;sumB+=t*hist[t];
  const mB=sumB/wB,mF=(sum-sumB)/wF;const vb=wB*wF*(mB-mF)*(mB-mF);if(vb>varMax){varMax=vb;thr=t;}}return thr|0;}
function dilate(m,W,H,it=1){let a=m.slice(0);for(let k=0;k<it;k++){const pad=new Uint8Array((W+2)*(H+2));for(let y=0;y<H;y++)pad.set(a.subarray(y*W,(y+1)*W),(y+1)*(W+2)+1);
  const out=new Uint8Array(W*H);for(let y=0;y<H;y++){for(let x=0;x<W;x++){let mx=0;for(let dy=0;dy<3;dy++)for(let dx=0;dx<3;dx++)mx=Math.max(mx,pad[(y+dy)*(W+2)+(x+dx)]);
  out[y*W+x]=mx>0?1:0;}}a=out;}return a;}
function erode(m,W,H,it=1){let a=m.slice(0);for(let k=0;k<it;k++){const pad=new Uint8Array((W+2)*(H+2));for(let y=0;y<H;y++)pad.set(a.subarray(y*W,(y+1)*W),(y+1)*(W+2)+1);
  const out=new Uint8Array(W*H);for(let y=0;y<H;y++){for(let x=0;x<W;x++){let mn=1;for(let dy=0;dy<3;dy++)for(let dx=0;dx<3;dx++)mn=Math.min(mn,pad[(y+dy)*(W+2)+(x+dx)]);
  out[y*W+x]=mn>0?1:0;}}a=out;}return a;}
function sobelMag(g,W,H){const out=new Uint8Array(W*H);const get=(x,y)=>g[Math.max(0,Math.min(H-1,y))*W+Math.max(0,Math.min(W-1,x))];
  for(let y=0;y<H;y++){for(let x=0;x<W;x++){const gx=(-1*get(x-1,y-1)+1*get(x+1,y-1)+-2*get(x-1,y)+2*get(x+1,y)+-1*get(x-1,y+1)+1*get(x+1,y+1));
  const gy=(-1*get(x-1,y-1)-2*get(x,y-1)-1*get(x+1,y-1)+1*get(x-1,y+1)+2*get(x,y+1)+1*get(x+1,y+1));out[y*W+x]=Math.min(255,Math.hypot(gx,gy)|0);}}return out;}
function floodBG(muro,isBgLike,W,H,rgbaFlat){const N=W*H;const bg=new Uint8Array(N);const q=new Uint32Array(N);let qs=0,qe=0;
  function push(p){if(bg[p]||muro[p])return;if(isBgLike && !isBgLike(p,rgbaFlat))return;bg[p]=1;q[qe++]=p;}
  for(let x=0;x<W;x++){push(x);push((H-1)*W+x);}for(let y=0;y<H;y++){push(y*W);push(y*W+(W-1));}
  while(qs<qe){const p=q[qs++],x=p%W,y=(p/W)|0;const neigh=[p-1,p+1,p-W,p+W];
    for(const u of neigh){if(u<0||u>=N)continue;const ux=u%W,uy=(u/W)|0;if(Math.abs(ux-x)+Math.abs(uy-y)!==1)continue;
      if(bg[u]||muro[u])continue;if(isBgLike && !isBgLike(u,rgbaFlat))continue;bg[u]=1;q[qe++]=u;}}return bg;}
function peelOutside(fg,protect,W,H,it=1){let out=fg.slice(0);for(let k=0;k<it;k++){const nxt=out.slice(0);
  for(let y=0;y<H;y++){for(let x=0;x<W;x++){const i=y*W+x;if(out[i]===0||protect[i]===1)continue;
    if((x>0&&out[i-1]===0)||(x<W-1&&out[i+1]===0)||(y>0&&out[i-W]===0)||(y<H-1&&out[i+W]===0))nxt[i]=0;}}out=nxt;}return out;}
async function knockoutProcess(imgBitmap,{ink=64,gap=-1,edge=18,bg_tol=24,feather=1.2,padding=24}={}){
  const W=imgBitmap.width,H=imgBitmap.height,c=document.createElement('canvas');c.width=W;c.height=H;
  const cx=c.getContext('2d');cx.drawImage(imgBitmap,0,0);const imgData=cx.getImageData(0,0,W,H);
  const gray=toGray(imgData);const thrInk=Math.round(0.5*(0.8*otsu(gray))+0.5*ink)|0;
  let ink_mask=new Uint8Array(W*H);for(let i=0;i<ink_mask.length;i++)ink_mask[i]=gray[i]<=thrInk?1:0;
  let ink_morph=gap>=0?dilate(ink_mask,W,H,gap):erode(ink_mask,W,H,-gap);const CLEAN=1;ink_morph=dilate(erode(ink_morph,W,H,CLEAN),W,H,CLEAN);
  const mag=sobelMag(gray,W,H);const edge_bin=new Uint8Array(W*H);for(let i=0;i<edge_bin.length;i++)edge_bin[i]=mag[i]>=edge?1:0;
  const edge_dil=dilate(edge_bin,W,H,1);
  let minx=W,miny=H,maxx=-1,maxy=-1;for(let y=0;y<H;y++)for(let x=0;x<W;x++)if(ink_morph[y*W+x]){if(x<minx)minx=x;if(x>maxx)maxx=x;if(y<miny)miny=y;if(y>maxy)maxy=y;}
  let rect=[0,0,W,H]; if(maxx>=0) rect=[minx,miny,(maxx-minx+1),(maxy-miny+1)];
  const [rx,ry,rw,rh]=rect;
  const edge_dil2=edge_dil.slice(0);const x0=Math.max(0,rx-1),y0=Math.max(0,ry-1),x1=Math.min(W-1,rx+rw+1),y1=Math.min(H-1,ry+rh+1);
  for(let y=y0;y<=y1;y++)for(let x=x0;x<=x1;x++)edge_dil2[y*W+x]=0;
  const band=28,yStart=Math.min(H-1,ry+rh+2),y1b=Math.min(H-1,yStart+band),x0b=Math.max(0,rx-band),x1b=Math.min(W-1,rx+rw+band);
  const mask_band=new Uint8Array(W*H);if(yStart<=y1b){for(let y=yStart;y<=y1b;y++)for(let x=x0b;x<=x1b;x++)mask_band[y*W+x]=1;}
  for(let i=0;i<edge_dil2.length;i++)edge_dil2[i]=edge_dil2[i]&mask_band[i];
  const guard=Math.max(1,gap>0?gap:0)+1,ink_barrier=dilate(ink_mask,W,H,guard);const seam=new Uint8Array(W*H);
  const yS=Math.min(H-1,ry+rh),xL=Math.max(0,rx-2),xR=Math.min(W-1,rx+rw+2);for(let y=yS;y<=Math.min(H-1,yS+1);y++)for(let x=xL;x<=xR;x++)seam[y*W+x]=1;
  const muro=new Uint8Array(W*H);for(let i=0;i<muro.length;i++)muro[i]=(ink_barrier[i]||edge_dil2[i]||seam[i])?1:0;
  const R=[],G=[],B=[],ring=2,coords=[];for(let xx=rx;xx<rx+rw;xx++){for(let r=0;r<ring;r++){coords.push((ry+r)*W+xx);coords.push((ry+rh-1-r)*W+xx);}}
  for(let yy=ry;yy<ry+rh;yy++){for(let r=0;r<ring;r++){coords.push(yy*W+(rx+r));coords.push(yy*W+(rx+rw-1-r));}}
  const rgbaFlat=imgData.data;for(const p of coords){const x=p%W,y=(p/W)|0;if(ink_morph[y*W+x])continue;const a=rgbaFlat[p*4+3];if(a<10)continue;
    R.push(rgbaFlat[p*4]),G.push(rgbaFlat[p*4+1]),B.push(rgbaFlat[p*4+2]);}
  const median=a=>{if(!a.length)return 0;const s=a.slice().sort((A,B)=>A-B);return s[(s.length/2)|0];};
  const bg_mean=[median(R),median(G),median(B)];
  const tol2=24*24*3.0;
  const bg=floodBG(muro,null,W,H,rgbaFlat);
  let fg=new Uint8Array(W*H);for(let i=0;i<fg.length;i++)fg[i]=bg[i]===0?1:0;fg=peelOutside(fg,ink_morph,W,H,5);
  const ringMask=dilate(ink_morph,W,H,1),ringOnly=new Uint8Array(W*H);for(let i=0;i<fg.length;i++)ringOnly[i]=(ringMask[i]===1&&ink_morph[i]===0)?1:0;
  const touch_bg=new Uint8Array(W*H);for(let y=0;y<H;y++){for(let x=0;x<W;x++){const i=y*W+x;if(!ringOnly[i])continue;const nb=[x>0?bg[i-1]:0,x<W-1?bg[i+1]:0,y>0?bg[i-W]:0,y<H-1?bg[i+W]:0]; if(nb.some(v=>v!==0))touch_bg[i]=1;}}
  for(let i=0;i<fg.length;i++) if(touch_bg[i]) fg[i]=0;

  // alpha + masked
  const alphaCanvas=document.createElement('canvas');alphaCanvas.width=W;alphaCanvas.height=H;const actx=alphaCanvas.getContext('2d');
  const rgba=new Uint8ClampedArray(W*H*4);for(let i=0;i<W*H;i++){rgba[i*4+3]=(fg[i]===1||ink_morph[i]===1)?255:0;}actx.putImageData(new ImageData(rgba,W,H),0,0);
  if(1.2>0){const blurC=document.createElement('canvas');blurC.width=W;blurC.height=H;const bctx=blurC.getContext('2d');bctx.filter=`blur(${1.2}px)`;bctx.drawImage(alphaCanvas,0,0);actx.clearRect(0,0,W,H);actx.drawImage(blurC,0,0);}

  const masked=document.createElement('canvas');masked.width=W;masked.height=H;const mctx=masked.getContext('2d');mctx.drawImage(imgBitmap,0,0);mctx.globalCompositeOperation='destination-in';mctx.drawImage(alphaCanvas,0,0);
  return { fullCanvas:masked, size_out:[W,H] };
}

/* ============ Viewer/Preview (UNICO) ============ */
const base=document.getElementById('compBase');
const ctxBase=base.getContext('2d');
const view=document.getElementById('view');
const stage=document.getElementById('stage');
let doodleCanvas=null, doodleDraw={x:0,y:0,w:1800,h:1800};
let previewFps=15, previewRunning=false;

function sizeViewer(css=900){
  const dpr=window.devicePixelRatio||1;
  view.width = css*dpr; view.height = css*dpr;
  view.style.width = css+'px'; view.style.height = css+'px';
  stage.style.width = css+'px'; stage.style.height = css+'px';
}

function drawFrameTo(ctx, W, H, svgBitmap){
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);
  if(doodleCanvas){
    ctx.drawImage(doodleCanvas, 0,0,doodleCanvas.width,doodleCanvas.height, doodleDraw.x,doodleDraw.y,doodleDraw.w,doodleDraw.h);
  }
  if(svgBitmap){ ctx.drawImage(svgBitmap,0,0,W,H); }
}

async function rasterizeCurrentSVG(){
  if(!svgEl) return null;
  const clone=svgEl.cloneNode(true);
  clone.setAttribute('width','1800'); clone.setAttribute('height','1800');
  clone.setAttribute('viewBox','0 0 1800 1800'); clone.setAttribute('preserveAspectRatio','xMidYMid meet');
  const svgStr=new XMLSerializer().serializeToString(clone);
  const svgBlob=new Blob([svgStr],{type:'image/svg+xml'});
  try{ return await createImageBitmap(svgBlob); }
  catch{ return await new Promise((resolve,reject)=>{ const url=URL.createObjectURL(svgBlob); const im=new Image();
    im.onload=()=>{resolve(im);URL.revokeObjectURL(url)}; im.onerror=e=>{reject(e);URL.revokeObjectURL(url)}; im.src=url; }); }
}

async function previewLoop(){
  if(previewRunning) return;
  previewRunning=true;
  const dpr=window.devicePixelRatio||1;
  const ctx=view.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  const css=view.clientWidth; // quadrato
  const scale = css/1800;

  while(previewRunning){
    // avanza Lottie a tempo reale
    if(anim && lottieData){
      // mappo il tempo della preview al framerate Lottie
      // (qui basta lasciarla in autoplay; forzo un reflow con goToAndStop del current time)
      const cur = anim.currentFrame;
      anim.goToAndStop(cur, true);
    }
    const svgBmp = await rasterizeCurrentSVG();
    // disegna sul canvas viewer a scala
    const tmp=document.createElement('canvas'); tmp.width=1800; tmp.height=1800;
    const tctx=tmp.getContext('2d');
    drawFrameTo(tctx, 1800, 1800, svgBmp);

    // ridisegna scalato nel viewer
    ctx.clearRect(0,0,css,css);
    ctx.drawImage(tmp, 0,0,1800,1800, 0,0,css,css);

    await sleep(1000/previewFps);
  }
}

/* ============ Export WebM ============ */
async function exportWebM(durationSec=3,fps=30){
  const recCanvas=document.createElement('canvas'); recCanvas.width=1800; recCanvas.height=1800;
  const rctx=recCanvas.getContext('2d'); const stream=recCanvas.captureStream(fps);
  const chunks=[]; const rec=new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9'});
  rec.ondataavailable=e=>{ if(e.data.size) chunks.push(e.data); };
  const done=new Promise(res=>rec.onstop=()=>res()); rec.start();
  const totalFrames=Math.floor(durationSec*fps);

  for(let f=0; f<totalFrames; f++){
    if(anim){ const fr=(lottieData?.fr)||30; const frame=Math.floor((f/fps)*fr)%Math.floor(anim.getDuration(true)); anim.goToAndStop(frame,true); await new Promise(r=>requestAnimationFrame(r)); }
    const svgBmp=await rasterizeCurrentSVG();
    drawFrameTo(rctx, 1800, 1800, svgBmp);
    await sleep(1000/fps);
  }
  rec.stop(); await done;
  const blob=new Blob(chunks,{type:'video/webm'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='doodle_demo.webm'; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),10000);
}
async function exportAPNG(durationSec = 3, fps = 20, outSize = 900){
  if (!window.UPNG) { alert('Libreria APNG non caricata'); return; }

  // master 1800→ downscale a outSize (come per GIF)
  const master = document.createElement('canvas'); master.width = 1800; master.height = 1800;
  const mctx = master.getContext('2d');
  const out = document.createElement('canvas'); out.width = outSize; out.height = outSize;
  const octx = out.getContext('2d');

  const totalFrames = Math.floor(durationSec * fps);
  const delayMsPerFrame = Math.round(1000 / fps);

  const btn = document.getElementById('btnExportAPNG');
  if (btn){ var old = btn.textContent; btn.disabled = true; }

  // raccogliamo i frame come ImageData RGBA 8-bit
  const frames = [];
  for (let f = 0; f < totalFrames; f++){
    if (anim){
      const fr = (lottieData?.fr) || 30;
      const frame = Math.floor((f / fps) * fr) % Math.floor(anim.getDuration(true));
      anim.goToAndStop(frame, true);
      await new Promise(r => requestAnimationFrame(r));
    }

    const svgBmp = await rasterizeCurrentSVG();
    // disegna master pieno
    drawFrameTo(mctx, 1800, 1800, svgBmp);

    // downscale pulito
    octx.clearRect(0,0,outSize,outSize);
    octx.imageSmoothingEnabled = true;
    octx.imageSmoothingQuality = 'high';
    octx.filter = 'blur(0.15px)'; // micro-blur evita aliasing/banding
    octx.drawImage(master, 0,0,1800,1800, 0,0,outSize,outSize);
    octx.filter = 'none';

    // cattura ImageData
    frames.push(octx.getImageData(0,0,outSize,outSize).data.buffer);
    if (btn && f % 3 === 0) btn.textContent = `Export APNG… ${Math.round((f+1)/totalFrames*100)}%`;
  }

  // UPNG.encode(buffers, width, height, colorDepth, delays, [filters])
  // colorDepth: 0=auto (lossless 8-bit per canale). Delays in ms per frame.
  const delays = new Array(totalFrames).fill(delayMsPerFrame);
  const apng = UPNG.encode(frames, outSize, outSize, 0, delays);

  const blob = new Blob([apng], { type: 'image/png' }); // APNG è un PNG animato
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `doodle_${outSize}px_${fps}fps.apng`; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 10000);

  if (btn){ btn.disabled = false; btn.textContent = old; }
}

/* ============ Export GIF (downscale + robust) ============ */
async function exportGIF(durationSec=3, fps=30, outSize=900){
  if(!window.GIF){ alert('Libreria GIF non caricata'); return; }

  const workerURL = await ensureGifWorkerUrl();

  const master=document.createElement('canvas'); master.width=1800; master.height=1800;
  const mctx=master.getContext('2d');
  const out=document.createElement('canvas'); out.width=outSize; out.height=outSize;
  const octx=out.getContext('2d');

  const gif = new GIF({
    workers: 4,
    quality: 12,            // 10–16 qualità/peso ok; 30 = più leggero ma peggiore
    width: outSize,
    height: outSize,
    workerScript: workerURL,
    repeat: 0,
    dither: false
  });

  const totalFrames = Math.floor(durationSec * fps);
  const delayMs = Math.round(1000 / fps);  // 30 fps => ~33 ms

  const btn = document.getElementById('btnExportGIF');
  const old = btn.textContent; btn.disabled = true;

  for(let f=0; f<totalFrames; f++){
    if(anim){
      const fr = (lottieData?.fr) || 30;
      const frame = Math.floor((f / fps) * fr) % Math.floor(anim.getDuration(true));
      anim.goToAndStop(frame, true);
      await new Promise(r => requestAnimationFrame(r));
    }

    const svgBmp = await rasterizeCurrentSVG();
    drawFrameTo(mctx, 1800, 1800, svgBmp);

    // downscale con smoothing di qualità
    octx.clearRect(0,0,outSize,outSize);
    octx.imageSmoothingEnabled = true;
    octx.imageSmoothingQuality = 'high';
    octx.drawImage(master, 0,0,1800,1800, 0,0,outSize,outSize);

    gif.addFrame(octx, { copy: true, delay: delayMs });   // <- parentesi chiusa correttamente
    if (f % 3 === 0) btn.textContent = `Export GIF… ${Math.round((f+1)/totalFrames*100)}%`;
  }

  gif.on('progress', p => { btn.textContent = `Packing GIF… ${Math.round(p*100)}%`; });
  gif.on('finished', blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `doodle_${outSize}px_${fps}fps.gif`; a.click();
    setTimeout(() => URL.revokeObjectURL(url), 10000);
    btn.disabled = false; btn.textContent = old;
  });

  gif.render();
}


/* ============ Assets auto-load ============ */
let META=null, COLORS=null;
function basePath(){ const u=new URL(window.location.href); u.hash=''; u.search=''; if(u.pathname.includes('/')) u.pathname=u.pathname.replace(/\/[^\/]*$/,'/'); return u.toString(); }
async function autoLoadAssets(){
  const base=basePath();
  try{ const r=await fetchWithTimeout(base+'Corrispondenze_Nome_Hex.csv',{timeout:8000,cache:'no-cache'}); if(!r.ok) throw new Error(r.status); COLORS=parseColorCsv(await r.text()); }
  catch{ COLORS=parseColorCsv(`Skin 1;#F5B39A
Skin 4;#E7C8A1
Yellow 1;#FFD84D
Purple 1;#C39BFF
Light Blue 1;#9BE2FF
Pink 1;#FF9BC9
Gradient 2;#95EAEC|#E6BCF9`);}

  try{ const r=await fetchWithTimeout(base+'Doodles_all_metadata.json',{timeout:8000,cache:'no-cache'}); if(!r.ok) throw new Error(r.status); META=await r.json(); }
  catch{ META={
    "0":{"image":"ipfs://QmUEfFfwAh4wyB5UfHCVPUxis4j4Q4kJXtm5x5p3g1fVUn","Skin_colors":"Skin 1","Sleeve_colors":"Yellow 1"},
    "1":{"image":"ipfs://QmTDxnzcvj2p3xBrKcGv1wxoyhAn2yzCQnZZ9LmFjReuH9","Skin_colors":"Gradient 2","Sleeve_colors":"Purple 1"}
  };}

  try{ const r=await fetchWithTimeout(base+'anim.json',{timeout:8000,cache:'no-cache'}); if(!r.ok) throw new Error(r.status); await loadAnimFromJson(await r.json()); }
  catch{ /* overlay opzionale */ }
}

/* ============ Compose & recolor ============ */
function getRecord(meta,id){ const r=meta[String(id)]; if(!r) throw new Error('ID non trovato nei metadata: '+id);
  return { image:r.image, skinName:r.Skin_colors, sleeveName:r.Sleeve_colors };
}
async function composeFromId(){
  try{
    const id=Number(document.getElementById('doodleId').value);
    if(!Number.isFinite(id)) throw new Error('ID non valido');
    const rec=getRecord(META,id);
    const urls=ipfsToHttpFallbacks(rec.image);
    const resp=await fetchWithFallback(urls,{timeout:9000,mode:'cors'});
    const blob=await resp.blob();

    let bmp=null;
    try{ bmp=await createImageBitmap(blob,{colorSpaceConversion:'none',premultiplyAlpha:'default'}); }
    catch{ bmp=await new Promise((resolve,reject)=>{ const url=URL.createObjectURL(blob); const im=new Image();
      im.onload=()=>{resolve(im);URL.revokeObjectURL(url)}; im.onerror=e=>{reject(e);URL.revokeObjectURL(url)}; im.src=url; }); }

    const { fullCanvas, size_out } = await knockoutProcess(bmp,{ink:64,gap:-1,edge:18,bg_tol:24,feather:1.2,padding:24});
    doodleCanvas=fullCanvas;

    if(size_out && size_out[0]===1800 && size_out[1]===1800){ doodleDraw={x:0,y:0,w:1800,h:1800}; }
    else{ const W=fullCanvas.width,H=fullCanvas.height,s=Math.min(1800/W,1800/H); doodleDraw={x:0,y:0,w:Math.round(W*s),h:Math.round(H*s)}; }

    // recolor overlay
    if(svgEl && COLORS){
      tagAllLayersWithNames(anim);
      const skinStops=COLORS.getStops(rec.skinName), sleeveStops=COLORS.getStops(rec.sleeveName);
      (skinStops.length===1?setLayerFlatByName:setLayerGradientStopsByName)(svgEl,LAYER_SKIN,skinStops,'horizontal');
      (sleeveStops.length===1?setLayerFlatByName:setLayerGradientStopsByName)(svgEl,LAYER_SLEEVE,sleeveStops,'horizontal');
      setSoftLightByName(svgEl,LAYER_SHADOW,0.8);
    }

    // start/refresh preview
    sizeViewer(900);
    previewFps=30;
    previewRunning=false;
    requestAnimationFrame(()=>previewLoop());
  }catch(err){ console.error(err); alert('Errore: '+(err.message||String(err))); }
}

/* ============ Init/Bindings ============ */
function init(){
  sizeViewer(900);
  autoLoadAssets();
}
document.getElementById('btnCompose').onclick=composeFromId;
document.getElementById('btnExportWebM').onclick=()=>exportWebM(3,30);
document.getElementById('btnExportGIF').onclick=()=>exportGIF(3, Number(document.getElementById('gifFps').value||30), Number(document.getElementById('gifSize').value||900));
document.getElementById('btnExportAPNG').onclick = () =>
  exportAPNG(3, Number(document.getElementById('gifFps').value || 20),
                Number(document.getElementById('gifSize').value || 900));

init();
// ---- Worker GIF: crea un blob URL same-origin a runtime ----
let GIF_WORKER_URL = null;

async function ensureGifWorkerUrl() {
  if (GIF_WORKER_URL) return GIF_WORKER_URL;
  const cdn = 'https://unpkg.com/gif.js.optimized/dist/gif.worker.js';
  const res = await fetch(cdn, { cache: 'no-cache' });
  if (!res.ok) throw new Error('Impossibile scaricare gif.worker.js: ' + res.status);
  const code = await res.text();
  const blob = new Blob([code], { type: 'application/javascript' });
  GIF_WORKER_URL = URL.createObjectURL(blob);
  return GIF_WORKER_URL;
}

// opzionale: pulizia quando chiudi la pagina
window.addEventListener('beforeunload', () => {
  if (GIF_WORKER_URL) URL.revokeObjectURL(GIF_WORKER_URL);
});
<script>
  // Alcune build di UPNG cercano una funzione di deflate globale.
  // Se c’è pako, instradiamo la compressione verso pako.deflate.
  (function(){
    if (window.UPNG && window.pako) {
      // UPNG usa internamente una funzione di compressione; la agganciamo a pako
      if (!UPNG.compress && UPNG.encode) {
        // fallback su alcune varianti
        UPNG.compress = function(buf){ return pako.deflate(new Uint8Array(buf)); };
      }
      if (UPNG.encode) {
        // patch comune: alcune build leggono encode.compress
        UPNG.encode.compress = function(buf){ return pako.deflate(new Uint8Array(buf)); };
      }
    }
  })();
</script>

</script>
</body>
</html>
