<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Doodles — Export Video (auto MP4/WebM, fps/dur da anim.json)</title>
  <link rel="icon" href="data:,">
  <style>
    :root{--bg:#0f1115;--card:#171a21;--text:#eef2ff;--muted:#9aa3b2;--border:#232938;--ok:#67e8f9;--warn:#ffd166}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto}
    .wrap{max-width:980px;margin:20px auto;padding:0 16px;display:grid;gap:14px}
    .panel{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px}
    h1{margin:0 0 6px;font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{color:var(--muted)}
    input[type="number"],button{background:#0c0e13;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px 10px}
    button{cursor:pointer}
    button.primary{border-color:var(--ok);color:var(--ok)}
    #stageWrap{position:relative;border:1px dashed var(--border);border-radius:14px;overflow:hidden;background:#fff}
    #stage{position:relative;margin:auto}
    #view{display:block}
    #lottieOff{position:absolute;left:-99999px;top:-99999px;width:1px;height:1px;overflow:hidden}
    .hint{color:var(--warn)}
  </style>

  <!-- Lottie -->
  <script src="https://unpkg.com/lottie-web/build/player/lottie.min.js"></script>
</head>
<body>
<div class="wrap">
  <h1>Doodles — Export Video</h1>

  <div class="panel">
    <div class="row">
      <label for="doodleId">ID Doodle:</label>
      <input type="number" id="doodleId" placeholder="es. 0" min="0" style="width:120px">
      <button id="btnCompose" class="primary">Fetch &amp; Compose</button>
      <button id="btnExportVID">Export Video</button>
      <span class="hint" id="fmtHint"></span>
    </div>
  </div>

  <div class="panel">
    <div id="stageWrap">
      <div id="stage">
        <canvas id="view"></canvas>
      </div>
    </div>
  </div>

  <!-- Lottie off-screen -->
  <div id="lottieOff"></div>

<script>
/* ========================= Config fissi ========================= */
const OUT_SIZE = 900;                  // 900x900 fissi in output
const MASTER_SIZE = 1800;              // render master (svg raster + doodle)
const MICRO_BLUR = 0.25;               // anti-rumore/banding sul downscale
const VIDEO_BITRATE = 8_000_000;       // ~8 Mbps (qualità molto buona)

/* ========================= Utils & IPFS ========================= */
const IPFS_GATEWAYS = [
  'https://ipfs.io/ipfs/','https://dweb.link/ipfs/','https://cf-ipfs.com/ipfs/',
  'https://gateway.pinata.cloud/ipfs/','https://nftstorage.link/ipfs/'
];
const sleep = ms => new Promise(r=>setTimeout(r,ms));
async function fetchWithTimeout(url,{timeout=8000,...opts}={}){const ctrl=new AbortController();const t=setTimeout(()=>ctrl.abort('timeout'),timeout);try{return await fetch(url,{...opts,signal:ctrl.signal});}finally{clearTimeout(t);}}
async function fetchWithFallback(urls,{timeout=8000,...opts}={}){let last=null;for(const u of urls){try{const r=await fetchWithTimeout(u,{timeout,...opts});if(r.ok) return r;last=new Error('HTTP '+r.status);}catch(e){last=e}}throw last||new Error('All gateways failed');}
function ipfsToHttpFallbacks(ipfsUrl){if(!ipfsUrl) return [];const path=ipfsUrl.startsWith('ipfs://')?ipfsUrl.slice(7):ipfsUrl;const cb='?cb='+Date.now().toString(36);return IPFS_GATEWAYS.map(g=>g+path+cb);}

/* ========================= Posterize (stabilità colori opzionale) ========================= */
function makePosterizeLUT(bits=6){const lut=new Uint8Array(256);const shift=8-bits;for(let i=0;i<256;i++) lut[i]=(i>>shift)<<shift;return lut;}
const POSTER_LUT = makePosterizeLUT(6);
function posterizeImageData(imgData){
  const d=imgData.data;for(let i=0;i<d.length;i+=4){d[i]=POSTER_LUT[d[i]];d[i+1]=POSTER_LUT[d[i+1]];d[i+2]=POSTER_LUT[d[i+2]];}
  return imgData;
}
function parseColorCsv(text){
  const lines=text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const map=new Map(); const norm=s=>String(s).trim().toLowerCase();
  for(const raw of lines){const useSemi=raw.split(';').length>raw.split(',').length;const parts=raw.split(useSemi?';':',');if(parts.length<2) continue;
    const name=parts.shift(); const hex=parts.join(useSemi?';':','); if(!name||!hex) continue;
    map.set(norm(name), hex.includes('|')?hex.split('|').map(s=>s.trim()):hex.trim());
  }
  return { getStops(name){ const v=map.get(norm(name)); if(!v) throw new Error('Colore non trovato: '+name); return Array.isArray(v)?v:[v]; } };
}

/* ========================= Lottie helpers ========================= */
const LAYER_SKIN='Skin_fill',LAYER_SLEEVE='Sleeve_fill',LAYER_SHADOW='Shadow_fill';
let anim=null, svgEl=null, lottieData=null;
function tagAllLayersWithNames(animation){
  const tag=(el)=>{ const name=el?.data?.nm; const dom=el?.layerElement||el?.baseElement||el?.parentContainer||null;
    if(name&&dom?.setAttribute) dom.setAttribute('data-name',name);
    if(el?.elements?.length) el.elements.forEach(tag);
  };
  (animation?.renderer?.elements||[]).forEach(tag);
}
function getLayerRoots(svg,name){ return [...svg.querySelectorAll(`[data-name="${name}"]`)]; }
function getLayerShapesByName(svg,name){ const roots=getLayerRoots(svg,name), set=new Set(); roots.forEach(r=>{ r.querySelectorAll('path,polygon,rect,circle,ellipse,use,g').forEach(n=>set.add(n)); }); return [...set]; }
function forceFill(node,val){ node.setAttribute('fill',val); node.style.setProperty('fill',val,'important'); }
function ensureDefs(svg){ let d=svg.querySelector('defs'); if(!d){ d=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.prepend(d);} return d; }
function injectLinearGradient(svg,id,stops,attrs){ const defs=ensureDefs(svg), lg=document.createElementNS('http://www.w3.org/2000/svg','linearGradient'); lg.setAttribute('id',id); Object.entries(attrs).forEach(([k,v])=>lg.setAttribute(k,v)); stops.forEach(s=>{ const st=document.createElementNS('http://www.w3.org/2000/svg','stop'); st.setAttribute('offset',s.offset); st.setAttribute('stop-color',s.color); if(s.opacity!=null) st.setAttribute('stop-opacity',s.opacity); lg.appendChild(st); }); defs.appendChild(lg); return id; }
function setLayerFlatByName(svg,name,color){ getLayerShapesByName(svg,name).forEach(n=>forceFill(n,color)); }
function setLayerGradientStopsByName(svg,name,hexList,orientation='horizontal'){
  const id=`grad_${name}_${Date.now()}`, n=hexList.length;
  const stops=hexList.map((c,i)=>({offset:(n===1?0:(i/(n-1)))*100+'%',color:c}));
  const attrs=orientation==='horizontal'?{x1:'0%',y1:'0%',x2:'100%',y2:'0%'}:{x1:'0%',y1:'0%',x2:'0%',y2:'100%'};
  injectLinearGradient(svg,id,stops,attrs);
  getLayerShapesByName(svg,name).forEach(n=>forceFill(n,`url(#${id})`));
}
function setSoftLightByName(svg,name,opacity=.8){ getLayerRoots(svg,name).forEach(r=>{ r.style.mixBlendMode='soft-light'; r.style.opacity=String(opacity); }); }
async function loadAnimFromJson(json){
  lottieData=json;
  if(anim){ try{anim.destroy();}catch{} }
  anim=lottie.loadAnimation({container:document.getElementById('lottieOff'),renderer:'svg',loop:true,autoplay:true,animationData:lottieData});
  anim.addEventListener('DOMLoaded',()=>{
    svgEl=anim.renderer.svgElement;
    svgEl.setAttribute('viewBox',`0 0 ${MASTER_SIZE} ${MASTER_SIZE}`);
    svgEl.setAttribute('preserveAspectRatio','xMidYMid meet');
    tagAllLayersWithNames(anim);
    setSoftLightByName(svgEl,LAYER_SHADOW,0.8);
  });
}

/* ========================= Knockout (ritaglio doodle) ========================= */
/* (algoritmi compatti) */
function toGray(imgData){const{data,width,height}=imgData;const gray=new Uint8Array(width*height);
  for(let i=0,j=0;i<data.length;i+=4,j++){const r=data[i],g=data[i+1],b=data[i+2];gray[j]=Math.min(255,(0.299*r+0.587*g+0.114*b)|0);}return gray;}
function otsu(gray){const hist=new Float64Array(256);for(let i=0;i<gray.length;i++)hist[gray[i]]++;const total=gray.length;let sum=0;for(let t=0;t<256;t++)sum+=t*hist[t];
  let sumB=0,wB=0,varMax=0,thr=96;for(let t=0;t<256;t++){wB+=hist[t];if(wB===0)continue;const wF=total-wB;if(wF===0)break;sumB+=t*hist[t];
  const mB=sumB/wB,mF=(sum-sumB)/wF;const vb=wB*wF*(mB-mF)*(mB-mF);if(vb>varMax){varMax=vb;thr=t;}}return thr|0;}
function dilate(m,W,H,it=1){let a=m.slice(0);for(let k=0;k<it;k++){const pad=new Uint8Array((W+2)*(H+2));for(let y=0;y<H;y++)pad.set(a.subarray(y*W,(y+1)*W),(y+1)*(W+2)+1);
  const out=new Uint8Array(W*H);for(let y=0;y<H;y++){for(let x=0;x<W;x++){let mx=0;for(let dy=0;dy<3;dy++)for(let dx=0;dx<3;dx++)mx=Math.max(mx,pad[(y+dy)*(W+2)+(x+dx)]);
  out[y*W+x]=mx>0?1:0;}}a=out;}return a;}
function erode(m,W,H,it=1){let a=m.slice(0);for(let k=0;k<it;k++){const pad=new Uint8Array((W+2)*(H+2));for(let y=0;y<H;y++)pad.set(a.subarray(y*W,(y+1)*W),(y+1)*(W+2)+1);
  const out=new Uint8Array(W*H);for(let y=0;y<H;y++){for(let x=0;x<W;x++){let mn=1;for(let dy=0;dy<3;dy++)for(let dx=0;dx<3;dx++)mn=Math.min(mn,pad[(y+dy)*(W+2)+(x+dx)]);
  out[y*W+x]=mn>0?1:0;}}a=out;}return a;}
function sobelMag(g,W,H){const out=new Uint8Array(W*H);const get=(x,y)=>g[Math.max(0,Math.min(H-1,y))*W+Math.max(0,Math.min(W-1,x))];
  for(let y=0;y<H;y++){for(let x=0;x<W;x++){const gx=(-1*get(x-1,y-1)+1*get(x+1,y-1)+-2*get(x-1,y)+2*get(x+1,y)+-1*get(x-1,y+1)+1*get(x+1,y+1));
  const gy=(-1*get(x-1,y-1)-2*get(x,y-1)-1*get(x+1,y-1)+1*get(x-1,y+1)+2*get(x,y+1)+1*get(x+1,y+1));out[y*W+x]=Math.min(255,Math.hypot(gx,gy)|0);}}return out;}
function floodBG(muro,isBgLike,W,H,rgbaFlat){const N=W*H;const bg=new Uint8Array(N);const q=new Uint32Array(N);let qs=0,qe=0;
  function push(p){if(bg[p]||muro[p])return;if(isBgLike && !isBgLike(p,rgbaFlat))return;bg[p]=1;q[qe++]=p;}
  for(let x=0;x<W;x++){push(x);push((H-1)*W+x);}for(let y=0;y<H;y++){push(y*W);push(y*W+(W-1));}
  while(qs<qe){const p=q[qs++],x=p%W,y=(p/W)|0;const neigh=[p-1,p+1,p-W,p+W];
    for(const u of neigh){if(u<0||u>=N)continue;const ux=u%W,uy=(u/W)|0;if(Math.abs(ux-x)+Math.abs(uy-y)!==1)continue;
      if(bg[u]||muro[u])continue;if(isBgLike && !isBgLike(u,rgbaFlat))continue;bg[u]=1;q[qe++]=u;}}return bg;}
function peelOutside(fg,protect,W,H,it=1){let out=fg.slice(0);for(let k=0;k<it;k++){const nxt=out.slice(0);
  for(let y=0;y<H;y++){for(let x=0;x<W;x++){const i=y*W+x;if(out[i]===0||protect[i]===1)continue;
    if((x>0&&out[i-1]===0)||(x<W-1&&out[i+1]===0)||(y>0&&out[i-W]===0)||(y<H-1&&out[i+W]===0))nxt[i]=0;}}out=nxt;}return out;}
async function knockoutProcess(imgBitmap,{ink=64,gap=-1,edge=18,bg_tol=24,feather=1.2,padding=24}={}){
  const W=imgBitmap.width,H=imgBitmap.height,c=document.createElement('canvas');c.width=W;c.height=H;
  const cx=c.getContext('2d');cx.drawImage(imgBitmap,0,0);const imgData=cx.getImageData(0,0,W,H);
  const gray=toGray(imgData);const thrInk=Math.round(0.5*(0.8*otsu(gray))+0.5*ink)|0;
  let ink_mask=new Uint8Array(W*H);for(let i=0;i<ink_mask.length;i++)ink_mask[i]=gray[i]<=thrInk?1:0;
  let ink_morph=gap>=0?dilate(ink_mask,W,H,gap):erode(ink_mask,W,H,-gap);const CLEAN=1;ink_morph=dilate(erode(ink_morph,W,H,CLEAN),W,H,CLEAN);
  const mag=sobelMag(gray,W,H);const edge_bin=new Uint8Array(W*H);for(let i=0;i<edge_bin.length;i++)edge_bin[i]=mag[i]>=edge?1:0;
  const edge_dil=dilate(edge_bin,W,H,1);
  let minx=W,miny=H,maxx=-1,maxy=-1;for(let y=0;y<H;y++)for(let x=0;x<W;x++)if(ink_morph[y*W+x]){if(x<minx)minx=x;if(x>maxx)maxx=x;if(y<miny)miny=y;if(y>maxy)maxy=y;}
  let rect=[0,0,W,H]; if(maxx>=0) rect=[minx,miny,(maxx-minx+1),(maxy-miny+1)];
  const [rx,ry,rw,rh]=rect;
  const edge_dil2=edge_dil.slice(0);const x0=Math.max(0,rx-1),y0=Math.max(0,ry-1),x1=Math.min(W-1,rx+rw+1),y1=Math.min(H-1,ry+rh+1);
  for(let y=y0;y<=y1;y++)for(let x=x0;x<=x1;x++)edge_dil2[y*W+x]=0;
  const guard=Math.max(1,gap>0?gap:0)+1,ink_barrier=dilate(ink_mask,W,H,guard);const seam=new Uint8Array(W*H);
  const yS=Math.min(H-1,ry+rh),xL=Math.max(0,rx-2),xR=Math.min(W-1,rx+rw+2);for(let y=yS;y<=Math.min(H-1,yS+1);y++)for(let x=xL;x<=xR;x++)seam[y*W+x]=1;
  const muro=new Uint8Array(W*H);for(let i=0;i<muro.length;i++)muro[i]=(ink_barrier[i]||edge_dil2[i]||seam[i])?1:0;
  const rgbaFlat=imgData.data;const bg=floodBG(muro,null,W,H,rgbaFlat);
  let fg=new Uint8Array(W*H);for(let i=0;i<fg.length;i++)fg[i]=bg[i]===0?1:0;fg=peelOutside(fg,ink_morph,W,H,5);
  const alphaCanvas=document.createElement('canvas');alphaCanvas.width=W;alphaCanvas.height=H;const actx=alphaCanvas.getContext('2d');
  const rgba=new Uint8ClampedArray(W*H*4);for(let i=0;i<W*H;i++){rgba[i*4+3]=(fg[i]===1||ink_morph[i]===1)?255:0;}actx.putImageData(new ImageData(rgba,W,H),0,0);
  if(1.2>0){const blurC=document.createElement('canvas');blurC.width=W;blurC.height=H;const bctx=blurC.getContext('2d');bctx.filter=`blur(${1.2}px)`;bctx.drawImage(alphaCanvas,0,0);actx.clearRect(0,0,W,H);actx.drawImage(blurC,0,0);}
  const masked=document.createElement('canvas');masked.width=W;masked.height=H;const mctx=masked.getContext('2d');mctx.drawImage(imgBitmap,0,0);mctx.globalCompositeOperation='destination-in';mctx.drawImage(alphaCanvas,0,0);
  return { fullCanvas:masked, size_out:[W,H] };
}

/* ========================= Viewer ========================= */
const view = document.getElementById('view');
const stage = document.getElementById('stage');
let doodleCanvas=null, doodleDraw={x:0,y:0,w:MASTER_SIZE,h:MASTER_SIZE};
let previewRunning=false, previewFps=30;

function sizeViewer(css=OUT_SIZE){
  const dpr=window.devicePixelRatio||1;
  view.width = css*dpr; view.height = css*dpr;
  view.style.width = css+'px'; view.style.height = css+'px';
  stage.style.width = css+'px'; stage.style.height = css+'px';
}

function drawFrameTo(ctx, W, H, svgBitmap){
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);
  if(doodleCanvas){
    ctx.drawImage(doodleCanvas, 0,0,doodleCanvas.width,doodleCanvas.height, doodleDraw.x,doodleDraw.y,doodleDraw.w,doodleDraw.h);
  }
  if(svgBitmap){ ctx.drawImage(svgBitmap,0,0,W,H); }
}

async function rasterizeCurrentSVG(){
  if(!svgEl) return null;
  const clone=svgEl.cloneNode(true);
  clone.setAttribute('width',MASTER_SIZE); clone.setAttribute('height',MASTER_SIZE);
  clone.setAttribute('viewBox',`0 0 ${MASTER_SIZE} ${MASTER_SIZE}`);
  clone.setAttribute('preserveAspectRatio','xMidYMid meet');
  const svgStr=new XMLSerializer().serializeToString(clone);
  const svgBlob=new Blob([svgStr],{type:'image/svg+xml'});
  try{ return await createImageBitmap(svgBlob); }
  catch{
    return await new Promise((resolve,reject)=>{ const url=URL.createObjectURL(svgBlob); const im=new Image();
      im.onload=()=>{resolve(im);URL.revokeObjectURL(url)}; im.onerror=e=>{reject(e);URL.revokeObjectURL(url)}; im.src=url; });
  }
}

async function previewLoop(){
  if(previewRunning) return; previewRunning=true;
  const dpr=window.devicePixelRatio||1;
  const ctx=view.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
  const css=view.clientWidth;

  while(previewRunning){
    if(anim && lottieData){
      const cur = anim.currentFrame;
      anim.goToAndStop(cur, true);
    }
    const svgBmp = await rasterizeCurrentSVG();
    const master = document.createElement('canvas'); master.width=MASTER_SIZE; master.height=MASTER_SIZE;
    drawFrameTo(master.getContext('2d'), MASTER_SIZE, MASTER_SIZE, svgBmp);

    ctx.clearRect(0,0,css,css);
    ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
    ctx.drawImage(master, 0,0,MASTER_SIZE,MASTER_SIZE, 0,0,css,css);

    await sleep(1000/previewFps);
  }
}
async function offerMobileSave(blob, filename, mime){
  // 1) Prova lo share nativo con file (iOS/Android moderni)
  try{
    const file = new File([blob], filename, { type: mime });
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({
        files: [file],
        title: 'Export video',
        text: 'Doodles export'
      });
      return; // fatto ✅
    }
  }catch(e){ /* fallback sotto */ }

  // 2) Pagina di anteprima con <video> (long-press → "Salva video")
  const videoUrl = URL.createObjectURL(blob);
  const html = `
<!doctype html><meta charset="utf-8">
<title>${filename}</title>
<style>
  body{margin:0;background:#000;color:#fff;font:16px/1.4 system-ui}
  .wrap{max-width:900px;margin:0 auto;padding:16px}
  video{display:block;width:100%;height:auto;background:#000}
  .tip{opacity:.8;margin-top:10px}
  a.btn{display:inline-block;margin-top:12px;padding:10px 14px;border:1px solid #555;border-radius:10px;color:#fff;text-decoration:none}
</style>
<div class="wrap">
  <video src="${videoUrl}" controls playsinline loop></video>
  <div class="tip">📲 Su iPhone/iPad: tieni premuto sul video e scegli <b>“Salva video”</b>.<br>
  In alternativa usa il pulsante qui sotto.</div>
  <a class="btn" href="${videoUrl}" download="${filename}">⬇️ Scarica file</a>
</div>`;
  const page = URL.createObjectURL(new Blob([html], {type:'text/html'}));
  // iOS preferisce una nuova scheda per mostrare il menu nativo
  window.open(page, '_blank');
}

/* ========================= Export VIDEO via MediaRecorder ========================= */
// Selezione migliore MIME in base al browser
function pickBestMime(){
  const prefer = [
    'video/mp4;codecs=avc1.42E01E,mp4a.40.2', // Safari/iOS tipicamente
    'video/mp4',                               // generico mp4
    'video/webm;codecs=vp9,opus',
    'video/webm;codecs=vp8,opus',
    'video/webm'
  ];
  for(const m of prefer){ if(MediaRecorder.isTypeSupported?.(m)) return m; }
  return ''; // nessuno supportato
}

async function exportVideoFromAnim(){
  if(!lottieData || !anim){ alert('Animazione non pronta'); return; }

  // fps e range dai dati Lottie
  const fr = Math.min(60, Math.max(1, Math.round(Number(lottieData.fr)||30)));
  const ip = Math.round(lottieData.ip ?? 0);
  const op = Math.round(lottieData.op ?? anim.getDuration(true));
  const N  = Math.max(1, op - ip);                // numero frame "ufficiale" Lottie (ip..op-1)

  // canvases
  const master=document.createElement('canvas'); master.width=MASTER_SIZE; master.height=MASTER_SIZE;
  const mctx=master.getContext('2d');
  const out=document.createElement('canvas'); out.width=OUT_SIZE; out.height=OUT_SIZE;
  const octx=out.getContext('2d', { willReadFrequently: true });

  // MIME migliore disponibile (MP4 su iOS/Safari, WebM altrove)
  function pickBestMime(){
    const prefer = [
      'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
      'video/mp4',
      'video/webm;codecs=vp9,opus',
      'video/webm;codecs=vp8,opus',
      'video/webm'
    ];
    for(const m of prefer){ if(MediaRecorder.isTypeSupported?.(m)) return m; }
    return '';
  }
  const mime = pickBestMime();
  if(!mime){ alert('Browser senza MediaRecorder video compatibile'); return; }

  // UI
  const btn = document.getElementById('btnExportVID');
  const old = btn.textContent; btn.disabled = true; btn.textContent = 'Recording… 0%';
  const fmtHint = document.getElementById('fmtHint');
  fmtHint.textContent = 'Formato: ' + mime.split(';')[0].toUpperCase();

  // ferma la preview per non contendere la GPU
  previewRunning = false;

  // ========== PRE-ROLL: disegna PRIMO FRAME (ip) PRIMA di start ==========
  anim.goToAndStop(ip, true);
  await new Promise(r=>requestAnimationFrame(r));
  {
    const svgBmp0 = await rasterizeCurrentSVG();
    drawFrameTo(mctx, MASTER_SIZE, MASTER_SIZE, svgBmp0);
    octx.clearRect(0,0,OUT_SIZE,OUT_SIZE);
    octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality='high';
    octx.filter = `blur(${MICRO_BLUR}px)`;
    octx.drawImage(master, 0,0,MASTER_SIZE,MASTER_SIZE, 0,0,OUT_SIZE,OUT_SIZE);
    octx.filter = 'none';
    // posterize opzionale (stabilità cromatica)
    const img0 = octx.getImageData(0,0,OUT_SIZE,OUT_SIZE);
    posterizeImageData(img0);
    octx.putImageData(img0,0,0);
  }

  const stream = out.captureStream(fr);
  const chunks = [];
  const recorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
  recorder.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };

  // Avvio SENZA timeslice (Safari/iOS più stabile)
  recorder.start();

  // ========== RENDER: includiamo TUTTI i frame ==========
  // abbiamo già disegnato il frame ip; ora disegniamo ip+1 .. op-1 (totale N-1)
  let nextTick = performance.now() + 1000/fr;
  for(let f=1; f<N; f++){
    const frameIdx = ip + f; // ultimo = op-1
    anim.goToAndStop(frameIdx, true);
    await new Promise(r=>requestAnimationFrame(r));

    const svgBmp = await rasterizeCurrentSVG();
    drawFrameTo(mctx, MASTER_SIZE, MASTER_SIZE, svgBmp);

    octx.clearRect(0,0,OUT_SIZE,OUT_SIZE);
    octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality='high';
    octx.filter = `blur(${MICRO_BLUR}px)`;
    octx.drawImage(master, 0,0,MASTER_SIZE,MASTER_SIZE, 0,0,OUT_SIZE,OUT_SIZE);
    octx.filter = 'none';

    const img = octx.getImageData(0,0,OUT_SIZE,OUT_SIZE);
    posterizeImageData(img);
    octx.putImageData(img,0,0);

    // pacing a 1000/fr ms (niente attese extra dopo l’ultimo)
    nextTick += 1000/fr;
    const wait = Math.max(0, nextTick - performance.now());
    if(wait>0) await new Promise(r=>setTimeout(r, wait));

    if((f & 3) === 0){
      btn.textContent = `Recording… ${Math.round((f+1)/N*100)}%`;
    }
  }

  // ========== CHIUSURA PULITA ==========
  // Nessun "tick extra": mandiamo subito i dati e stoppiamo
  recorder.requestData();
  await new Promise(res=>{
    recorder.onstop = res;
    recorder.stop();
  });

  // Solo ORA chiudiamo le tracce (evita code nere in coda)
  stream.getTracks().forEach(t=>t.stop());

  // Blob & download
  const blob = new Blob(chunks, { type: mime });
  const url = URL.createObjectURL(blob);
  const ext = mime.includes('mp4') ? 'mp4' : 'webm';
  const fps = Math.round(Number(lottieData.fr)||fr);
  const a=document.createElement('a');
  const filename = `doodle_${OUT_SIZE}px_${fps}fps.${ext}`;
  
  offerMobileSave(blob, filename, mime);
  setTimeout(()=>URL.revokeObjectURL(url), 20000);

  btn.disabled = false; btn.textContent = old;

  // riparte la preview
  const frPreview = Math.min(60, Math.max(1, Math.round(lottieData?.fr || 30)));
  previewFps = frPreview;
  requestAnimationFrame(()=>{ previewRunning=false; previewLoop(); });
}


/* ========================= Auto-load asset (CSV, meta, anim.json) ========================= */
let META=null, COLORS=null;
function basePath(){ const u=new URL(window.location.href); u.hash=''; u.search=''; if(u.pathname.includes('/')) u.pathname=u.pathname.replace(/\/[^\/]*$/,'/'); return u.toString(); }
async function autoLoadAssets(){
  const base=basePath();
  try{ const r=await fetchWithTimeout(base+'Corrispondenze_Nome_Hex.csv',{timeout:8000,cache:'no-cache'}); COLORS=parseColorCsv(await r.text()); }
  catch{ COLORS=parseColorCsv(`Skin 1;#F5B39A
Skin 4;#E7C8A1
Yellow 1;#FFD84D
Purple 1;#C39BFF
Light Blue 1;#9BE2FF
Pink 1;#FF9BC9
Gradient 2;#95EAEC|#E6BCF9`); }

  try{ const r=await fetchWithTimeout(base+'Doodles_all_metadata.json',{timeout:8000,cache:'no-cache'}); META=await r.json(); }
  catch{ META={
    "0":{"image":"ipfs://QmUEfFfwAh4wyB5UfHCVPUxis4j4Q4kJXtm5x5p3g1fVUn","Skin_colors":"Skin 1","Sleeve_colors":"Yellow 1"},
    "1":{"image":"ipfs://QmTDxnzcvj2p3xBrKcGv1wxoyhAn2yzCQnZZ9LmFjReuH9","Skin_colors":"Gradient 2","Sleeve_colors":"Purple 1"}
  }; }

  const animResp = await fetchWithTimeout(base+'anim.json',{timeout:8000,cache:'no-cache'});
  if(!animResp.ok) throw new Error('anim.json mancante');
  await loadAnimFromJson(await animResp.json());

  // mostra formato previsto
  const fmt = pickBestMime();
  if(fmt) document.getElementById('fmtHint').textContent = 'Formato: ' + fmt.split(';')[0].toUpperCase();
}

/* ========================= Compose & recolor ========================= */
function getRecord(meta,id){ const r=meta[String(id)]; if(!r) throw new Error('ID non trovato nei metadata: '+id);
  return { image:r.image, skinName:r.Skin_colors, sleeveName:r.Sleeve_colors };
}
async function composeFromId(){
  try{
    const id=Number(document.getElementById('doodleId').value);
    if(!Number.isFinite(id)) throw new Error('ID non valido');
    const rec=getRecord(META,id);
    const urls=ipfsToHttpFallbacks(rec.image);
    const resp=await fetchWithFallback(urls,{timeout:9000,mode:'cors'});
    const blob=await resp.blob();

    let bmp=null;
    try{ bmp=await createImageBitmap(blob,{colorSpaceConversion:'none',premultiplyAlpha:'default'}); }
    catch{ bmp=await new Promise((resolve,reject)=>{ const url=URL.createObjectURL(blob); const im=new Image();
      im.onload=()=>{resolve(im);URL.revokeObjectURL(url)}; im.onerror=e=>{reject(e);URL.revokeObjectURL(url)}; im.src=url; }); }

    const { fullCanvas, size_out } = await knockoutProcess(bmp,{ink:64,gap:-1,edge:18,bg_tol:24,feather:1.2,padding:24});
    doodleCanvas=fullCanvas;

    if(size_out && size_out[0]===MASTER_SIZE && size_out[1]===MASTER_SIZE){ doodleDraw={x:0,y:0,w:MASTER_SIZE,h:MASTER_SIZE}; }
    else{ const W=fullCanvas.width,H=fullCanvas.height,s=Math.min(MASTER_SIZE/W,MASTER_SIZE/H); doodleDraw={x:0,y:0,w:Math.round(W*s),h:Math.round(H*s)}; }

    // recolor overlay
    if(svgEl && COLORS){
      tagAllLayersWithNames(anim);
      const skinStops=COLORS.getStops(rec.skinName), sleeveStops=COLORS.getStops(rec.sleeveName);
      (skinStops.length===1?setLayerFlatByName:setLayerGradientStopsByName)(svgEl,LAYER_SKIN,skinStops,'horizontal');
      (sleeveStops.length===1?setLayerFlatByName:setLayerGradientStopsByName)(svgEl,LAYER_SLEEVE,sleeveStops,'horizontal');
      setSoftLightByName(svgEl,LAYER_SHADOW,0.8);
    }

    // preview a fps originali (clamp 60)
    const fr = Math.min(60, Math.max(1, Math.round(lottieData?.fr || 30)));
    previewFps = fr;
    sizeViewer(OUT_SIZE);
    previewRunning=false;
    requestAnimationFrame(()=>previewLoop());
  }catch(err){ console.error(err); alert('Errore: '+(err.message||String(err))); }
}

/* ========================= Init ========================= */
function init(){
  sizeViewer(OUT_SIZE);
  autoLoadAssets().catch(e=>{ console.error(e); alert('Errore caricamento asset: '+e.message); });
  document.getElementById('btnCompose').onclick=composeFromId;
  document.getElementById('btnExportVID').onclick=exportVideoFromAnim;
}
init();
</script>
</body>
</html>
