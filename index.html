<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Doodles — Export GIF (900px, fps/dur da anim.json)</title>
  <link rel="icon" href="data:,">
  <style>
    :root{--bg:#0f1115;--card:#171a21;--text:#eef2ff;--muted:#9aa3b2;--border:#232938;--ok:#67e8f9}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto}
    .wrap{max-width:980px;margin:20px auto;padding:0 16px;display:grid;gap:14px}
    .panel{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px}
    h1{margin:0 0 6px;font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{color:var(--muted)}
    input[type="number"],button{background:#0c0e13;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px 10px}
    button{cursor:pointer}
    button.primary{border-color:var(--ok);color:var(--ok)}
    #stageWrap{position:relative;border:1px dashed var(--border);border-radius:14px;overflow:hidden;background:#fff}
    #stage{position:relative;margin:auto}
    #view{display:block}
    #lottieOff{position:absolute;left:-99999px;top:-99999px;width:1px;height:1px;overflow:hidden}
  </style>

  <!-- Lottie -->
  <script src="https://unpkg.com/lottie-web/build/player/lottie.min.js"></script>
  <!-- GIF encoder -->
  <script src="https://unpkg.com/gif.js.optimized/dist/gif.js"></script>
</head>
<body>
<div class="wrap">
  <h1>Doodles — Export GIF</h1>

  <div class="panel">
    <div class="row">
      <label for="doodleId">ID Doodle:</label>
      <input type="number" id="doodleId" placeholder="es. 0" min="0" style="width:120px">
      <button id="btnCompose" class="primary">Fetch &amp; Compose</button>
      <button id="btnExportGIF">Export GIF</button>
    </div>
  </div>

  <div class="panel">
    <div id="stageWrap">
      <div id="stage">
        <canvas id="view"></canvas>
      </div>
    </div>
  </div>

  <!-- Lottie off-screen -->
  <div id="lottieOff"></div>

<script>
/* ========================= Config fissi ========================= */
const OUT_SIZE = 900;                  // 900x900 fissi
const MASTER_SIZE = 1800;              // render master
const GIF_WORKERS = 4;
const GIF_QUALITY = 12;                // qualità alta (più peso), niente dither
const MICRO_BLUR = 0.25;               // anti-rumore/banding sul downscale

/* ========================= Utils & IPFS ========================= */
const IPFS_GATEWAYS = [
  'https://ipfs.io/ipfs/','https://dweb.link/ipfs/','https://cf-ipfs.com/ipfs/',
  'https://gateway.pinata.cloud/ipfs/','https://nftstorage.link/ipfs/'
];
const sleep = ms => new Promise(r=>setTimeout(r,ms));
async function fetchWithTimeout(url,{timeout=8000,...opts}={}){const ctrl=new AbortController();const t=setTimeout(()=>ctrl.abort('timeout'),timeout);try{return await fetch(url,{...opts,signal:ctrl.signal});}finally{clearTimeout(t);}}
async function fetchWithFallback(urls,{timeout=8000,...opts}={}){let last=null;for(const u of urls){try{const r=await fetchWithTimeout(u,{timeout,...opts});if(r.ok) return r;last=new Error('HTTP '+r.status);}catch(e){last=e}}throw last||new Error('All gateways failed');}
function ipfsToHttpFallbacks(ipfsUrl){if(!ipfsUrl) return [];const path=ipfsUrl.startsWith('ipfs://')?ipfsUrl.slice(7):ipfsUrl;const cb='?cb='+Date.now().toString(36);return IPFS_GATEWAYS.map(g=>g+path+cb);}

/* ========================= CSV colori (opzionale) ========================= */
// Posterize LUT: 6 bit per canale (64 livelli) -> colori stabili frame-to-frame
function makePosterizeLUT(bits=6){
  const lut = new Uint8Array(256);
  const shift = 8 - bits;
  for (let i=0;i<256;i++) lut[i] = (i >> shift) << shift;
  return lut;
}
const POSTER_LUT = makePosterizeLUT(6);

function posterizeImageData(imgData){
  const d = imgData.data;
  for (let i=0;i<d.length;i+=4){
    d[i]   = POSTER_LUT[d[i]];     // R
    d[i+1] = POSTER_LUT[d[i+1]];   // G
    d[i+2] = POSTER_LUT[d[i+2]];   // B
    // A lasciamo com'è
  }
  return imgData;
}

function parseColorCsv(text){
  const lines=text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const map=new Map(); const norm=s=>String(s).trim().toLowerCase();
  for(const raw of lines){
    const useSemi=raw.split(';').length>raw.split(',').length;
    const parts=raw.split(useSemi?';':','); if(parts.length<2) continue;
    const name=parts.shift(); const hex=parts.join(useSemi?';':',');
    if(!name||!hex) continue;
    map.set(norm(name), hex.includes('|')?hex.split('|').map(s=>s.trim()):hex.trim());
  }
  return { getStops(name){ const v=map.get(norm(name)); if(!v) throw new Error('Colore non trovato: '+name); return Array.isArray(v)?v:[v]; } };
}

/* ========================= Lottie helpers ========================= */
const LAYER_SKIN='Skin_fill',LAYER_SLEEVE='Sleeve_fill',LAYER_SHADOW='Shadow_fill';
let anim=null, svgEl=null, lottieData=null;
function tagAllLayersWithNames(animation){
  const tag=(el)=>{ const name=el?.data?.nm; const dom=el?.layerElement||el?.baseElement||el?.parentContainer||null;
    if(name&&dom?.setAttribute) dom.setAttribute('data-name',name);
    if(el?.elements?.length) el.elements.forEach(tag);
  };
  (animation?.renderer?.elements||[]).forEach(tag);
}
function getLayerRoots(svg,name){ return [...svg.querySelectorAll(`[data-name="${name}"]`)]; }
function getLayerShapesByName(svg,name){ const roots=getLayerRoots(svg,name), set=new Set(); roots.forEach(r=>{ r.querySelectorAll('path,polygon,rect,circle,ellipse,use,g').forEach(n=>set.add(n)); }); return [...set]; }
function forceFill(node,val){ node.setAttribute('fill',val); node.style.setProperty('fill',val,'important'); }
function ensureDefs(svg){ let d=svg.querySelector('defs'); if(!d){ d=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.prepend(d);} return d; }
function injectLinearGradient(svg,id,stops,attrs){ const defs=ensureDefs(svg), lg=document.createElementNS('http://www.w3.org/2000/svg','linearGradient'); lg.setAttribute('id',id); Object.entries(attrs).forEach(([k,v])=>lg.setAttribute(k,v)); stops.forEach(s=>{ const st=document.createElementNS('http://www.w3.org/2000/svg','stop'); st.setAttribute('offset',s.offset); st.setAttribute('stop-color',s.color); if(s.opacity!=null) st.setAttribute('stop-opacity',s.opacity); lg.appendChild(st); }); defs.appendChild(lg); return id; }
function setLayerFlatByName(svg,name,color){ getLayerShapesByName(svg,name).forEach(n=>forceFill(n,color)); }
function setLayerGradientStopsByName(svg,name,hexList,orientation='horizontal'){
  const id=`grad_${name}_${Date.now()}`, n=hexList.length;
  const stops=hexList.map((c,i)=>({offset:(n===1?0:(i/(n-1)))*100+'%',color:c}));
  const attrs=orientation==='horizontal'?{x1:'0%',y1:'0%',x2:'100%',y2:'0%'}:{x1:'0%',y1:'0%',x2:'0%',y2:'100%'};
  injectLinearGradient(svg,id,stops,attrs);
  getLayerShapesByName(svg,name).forEach(n=>forceFill(n,`url(#${id})`));
}
function setSoftLightByName(svg,name,opacity=.8){ getLayerRoots(svg,name).forEach(r=>{ r.style.mixBlendMode='soft-light'; r.style.opacity=String(opacity); }); }
async function loadAnimFromJson(json){
  lottieData=json;
  if(anim){ try{anim.destroy();}catch{} }
  anim=lottie.loadAnimation({container:document.getElementById('lottieOff'),renderer:'svg',loop:true,autoplay:true,animationData:lottieData});
  anim.addEventListener('DOMLoaded',()=>{
    svgEl=anim.renderer.svgElement;
    svgEl.setAttribute('viewBox',`0 0 ${MASTER_SIZE} ${MASTER_SIZE}`);
    svgEl.setAttribute('preserveAspectRatio','xMidYMid meet');
    tagAllLayersWithNames(anim);
    setSoftLightByName(svgEl,LAYER_SHADOW,0.8);
  });
}

/* ========================= Knockout (ritaglio doodle) ========================= */
/*  — identico al tuo: omesso per brevità e sicurezza visiva — */
function toGray(imgData){const{data,width,height}=imgData;const gray=new Uint8Array(width*height);
  for(let i=0,j=0;i<data.length;i+=4,j++){const r=data[i],g=data[i+1],b=data[i+2];gray[j]=Math.min(255,(0.299*r+0.587*g+0.114*b)|0);}return gray;}
function otsu(gray){const hist=new Float64Array(256);for(let i=0;i<gray.length;i++)hist[gray[i]]++;const total=gray.length;let sum=0;for(let t=0;t<256;t++)sum+=t*hist[t];
  let sumB=0,wB=0,varMax=0,thr=96;for(let t=0;t<256;t++){wB+=hist[t];if(wB===0)continue;const wF=total-wB;if(wF===0)break;sumB+=t*hist[t];
  const mB=sumB/wB,mF=(sum-sumB)/wF;const vb=wB*wF*(mB-mF)*(mB-mF);if(vb>varMax){varMax=vb;thr=t;}}return thr|0;}
function dilate(m,W,H,it=1){let a=m.slice(0);for(let k=0;k<it;k++){const pad=new Uint8Array((W+2)*(H+2));for(let y=0;y<H;y++)pad.set(a.subarray(y*W,(y+1)*W),(y+1)*(W+2)+1);
  const out=new Uint8Array(W*H);for(let y=0;y<H;y++){for(let x=0;x<W;x++){let mx=0;for(let dy=0;dy<3;dy++)for(let dx=0;dx<3;dx++)mx=Math.max(mx,pad[(y+dy)*(W+2)+(x+dx)]);
  out[y*W+x]=mx>0?1:0;}}a=out;}return a;}
function erode(m,W,H,it=1){let a=m.slice(0);for(let k=0;k<it;k++){const pad=new Uint8Array((W+2)*(H+2));for(let y=0;y<H;y++)pad.set(a.subarray(y*W,(y+1)*W),(y+1)*(W+2)+1);
  const out=new Uint8Array(W*H);for(let y=0;y<H;y++){for(let x=0;x<W;x++){let mn=1;for(let dy=0;dy<3;dy++)for(let dx=0;dx<3;dx++)mn=Math.min(mn,pad[(y+dy)*(W+2)+(x+dx)]);
  out[y*W+x]=mn>0?1:0;}}a=out;}return a;}
function sobelMag(g,W,H){const out=new Uint8Array(W*H);const get=(x,y)=>g[Math.max(0,Math.min(H-1,y))*W+Math.max(0,Math.min(W-1,x))];
  for(let y=0;y<H;y++){for(let x=0;x<W;x++){const gx=(-1*get(x-1,y-1)+1*get(x+1,y-1)+-2*get(x-1,y)+2*get(x+1,y)+-1*get(x-1,y+1)+1*get(x+1,y+1));
  const gy=(-1*get(x-1,y-1)-2*get(x,y-1)-1*get(x+1,y-1)+1*get(x-1,y+1)+2*get(x,y+1)+1*get(x+1,y+1));out[y*W+x]=Math.min(255,Math.hypot(gx,gy)|0);}}return out;}
function floodBG(muro,isBgLike,W,H,rgbaFlat){const N=W*H;const bg=new Uint8Array(N);const q=new Uint32Array(N);let qs=0,qe=0;
  function push(p){if(bg[p]||muro[p])return;if(isBgLike && !isBgLike(p,rgbaFlat))return;bg[p]=1;q[qe++]=p;}
  for(let x=0;x<W;x++){push(x);push((H-1)*W+x);}for(let y=0;y<H;y++){push(y*W);push(y*W+(W-1));}
  while(qs<qe){const p=q[qs++],x=p%W,y=(p/W)|0;const neigh=[p-1,p+1,p-W,p+W];
    for(const u of neigh){if(u<0||u>=N)continue;const ux=u%W,uy=(u/W)|0;if(Math.abs(ux-x)+Math.abs(uy-y)!==1)continue;
      if(bg[u]||muro[u])continue;if(isBgLike && !isBgLike(u,rgbaFlat))continue;bg[u]=1;q[qe++]=u;}}return bg;}
function peelOutside(fg,protect,W,H,it=1){let out=fg.slice(0);for(let k=0;k<it;k++){const nxt=out.slice(0);
  for(let y=0;y<H;y++){for(let x=0;x<W;x++){const i=y*W+x;if(out[i]===0||protect[i]===1)continue;
    if((x>0&&out[i-1]===0)||(x<W-1&&out[i+1]===0)||(y>0&&out[i-W]===0)||(y<H-1&&out[i+W]===0))nxt[i]=0;}}out=nxt;}return out;}
async function knockoutProcess(imgBitmap,{ink=64,gap=-1,edge=18,bg_tol=24,feather=1.2,padding=24}={}){
  const W=imgBitmap.width,H=imgBitmap.height,c=document.createElement('canvas');c.width=W;c.height=H;
  const cx=c.getContext('2d');cx.drawImage(imgBitmap,0,0);const imgData=cx.getImageData(0,0,W,H);
  const gray=toGray(imgData);const thrInk=Math.round(0.5*(0.8*otsu(gray))+0.5*ink)|0;
  let ink_mask=new Uint8Array(W*H);for(let i=0;i<ink_mask.length;i++)ink_mask[i]=gray[i]<=thrInk?1:0;
  let ink_morph=gap>=0?dilate(ink_mask,W,H,gap):erode(ink_mask,W,H,-gap);const CLEAN=1;ink_morph=dilate(erode(ink_morph,W,H,CLEAN),W,H,CLEAN);
  const mag=sobelMag(gray,W,H);const edge_bin=new Uint8Array(W*H);for(let i=0;i<edge_bin.length;i++)edge_bin[i]=mag[i]>=edge?1:0;
  const edge_dil=dilate(edge_bin,W,H,1);
  let minx=W,miny=H,maxx=-1,maxy=-1;for(let y=0;y<H;y++)for(let x=0;x<W;x++)if(ink_morph[y*W+x]){if(x<minx)minx=x;if(x>maxx)maxx=x;if(y<miny)miny=y;if(y>maxy)maxy=y;}
  let rect=[0,0,W,H]; if(maxx>=0) rect=[minx,miny,(maxx-minx+1),(maxy-miny+1)];
  const [rx,ry,rw,rh]=rect;
  const edge_dil2=edge_dil.slice(0);const x0=Math.max(0,rx-1),y0=Math.max(0,ry-1),x1=Math.min(W-1,rx+rw+1),y1=Math.min(H-1,ry+rh+1);
  for(let y=y0;y<=y1;y++)for(let x=x0;x<=x1;x++)edge_dil2[y*W+x]=0;
  const guard=Math.max(1,gap>0?gap:0)+1,ink_barrier=dilate(ink_mask,W,H,guard);const seam=new Uint8Array(W*H);
  const yS=Math.min(H-1,ry+rh),xL=Math.max(0,rx-2),xR=Math.min(W-1,rx+rw+2);for(let y=yS;y<=Math.min(H-1,yS+1);y++)for(let x=xL;x<=xR;x++)seam[y*W+x]=1;
  const muro=new Uint8Array(W*H);for(let i=0;i<muro.length;i++)muro[i]=(ink_barrier[i]||edge_dil2[i]||seam[i])?1:0;
  const R=[],G=[],B=[],ring=2,coords=[];for(let xx=rx;xx<rx+rw;xx++){for(let r=0;r<ring;r++){coords.push((ry+r)*W+xx);coords.push((ry+rh-1-r)*W+xx);}}
  for(let yy=ry;yy<ry+rh;yy++){for(let r=0;r<ring;r++){coords.push(yy*W+(rx+r));coords.push(yy*W+(rx+rw-1-r));}}
  const rgbaFlat=imgData.data;for(const p of coords){const x=p%W,y=(p/W)|0;if(ink_morph[y*W+x])continue;const a=rgbaFlat[p*4+3];if(a<10)continue;
    R.push(rgbaFlat[p*4]),G.push(rgbaFlat[p*4+1]),B.push(rgbaFlat[p*4+2]);}
  const median=a=>{if(!a.length)return 0;const s=a.slice().sort((A,B)=>A-B);return s[(s.length/2)|0];};
  const bg=floodBG(muro,null,W,H,rgbaFlat);
  let fg=new Uint8Array(W*H);for(let i=0;i<fg.length;i++)fg[i]=bg[i]===0?1:0;fg=peelOutside(fg,ink_morph,W,H,5);

  const alphaCanvas=document.createElement('canvas');alphaCanvas.width=W;alphaCanvas.height=H;const actx=alphaCanvas.getContext('2d');
  const rgba=new Uint8ClampedArray(W*H*4);for(let i=0;i<W*H;i++){rgba[i*4+3]=(fg[i]===1||ink_morph[i]===1)?255:0;}actx.putImageData(new ImageData(rgba,W,H),0,0);
  if(1.2>0){const blurC=document.createElement('canvas');blurC.width=W;blurC.height=H;const bctx=blurC.getContext('2d');bctx.filter=`blur(${1.2}px)`;bctx.drawImage(alphaCanvas,0,0);actx.clearRect(0,0,W,H);actx.drawImage(blurC,0,0);}

  const masked=document.createElement('canvas');masked.width=W;masked.height=H;const mctx=masked.getContext('2d');mctx.drawImage(imgBitmap,0,0);mctx.globalCompositeOperation='destination-in';mctx.drawImage(alphaCanvas,0,0);
  return { fullCanvas:masked, size_out:[W,H] };
}

/* ========================= Viewer ========================= */
const view = document.getElementById('view');
const stage = document.getElementById('stage');
let doodleCanvas=null, doodleDraw={x:0,y:0,w:MASTER_SIZE,h:MASTER_SIZE};
let previewRunning=false, previewFps=30;

function sizeViewer(css=OUT_SIZE){
  const dpr=window.devicePixelRatio||1;
  view.width = css*dpr; view.height = css*dpr;
  view.style.width = css+'px'; view.style.height = css+'px';
  stage.style.width = css+'px'; stage.style.height = css+'px';
}

function drawFrameTo(ctx, W, H, svgBitmap){
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);
  if(doodleCanvas){
    ctx.drawImage(doodleCanvas, 0,0,doodleCanvas.width,doodleCanvas.height, doodleDraw.x,doodleDraw.y,doodleDraw.w,doodleDraw.h);
  }
  if(svgBitmap){ ctx.drawImage(svgBitmap,0,0,W,H); }
}

async function rasterizeCurrentSVG(){
  if(!svgEl) return null;
  const clone=svgEl.cloneNode(true);
  clone.setAttribute('width',MASTER_SIZE); clone.setAttribute('height',MASTER_SIZE);
  clone.setAttribute('viewBox',`0 0 ${MASTER_SIZE} ${MASTER_SIZE}`);
  clone.setAttribute('preserveAspectRatio','xMidYMid meet');
  const svgStr=new XMLSerializer().serializeToString(clone);
  const svgBlob=new Blob([svgStr],{type:'image/svg+xml'});
  try{ return await createImageBitmap(svgBlob); }
  catch{
    return await new Promise((resolve,reject)=>{
      const url=URL.createObjectURL(svgBlob); const im=new Image();
      im.onload=()=>{resolve(im);URL.revokeObjectURL(url)}; im.onerror=e=>{reject(e);URL.revokeObjectURL(url)}; im.src=url;
    });
  }
}

async function previewLoop(){
  if(previewRunning) return;
  previewRunning=true;
  const dpr=window.devicePixelRatio||1;
  const ctx=view.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  const css=view.clientWidth;

  while(previewRunning){
    if(anim && lottieData){
      const cur = anim.currentFrame;
      anim.goToAndStop(cur, true);
    }
    const svgBmp = await rasterizeCurrentSVG();

    // master -> outSize per la preview
    const master = document.createElement('canvas'); master.width=MASTER_SIZE; master.height=MASTER_SIZE;
    drawFrameTo(master.getContext('2d'), MASTER_SIZE, MASTER_SIZE, svgBmp);

    ctx.clearRect(0,0,css,css);
    ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
    ctx.drawImage(master, 0,0,MASTER_SIZE,MASTER_SIZE, 0,0,css,css);

    await sleep(1000/previewFps);
  }
}

/* ========================= GIF worker (same-origin) ========================= */
let GIF_WORKER_URL = null;
async function ensureGifWorkerUrl(){
  if(GIF_WORKER_URL) return GIF_WORKER_URL;
  const res = await fetch('https://unpkg.com/gif.js.optimized/dist/gif.worker.js', {cache:'no-cache'});
  if(!res.ok) throw new Error('Impossibile scaricare gif.worker.js: '+res.status);
  const code = await res.text();
  const blob = new Blob([code], {type:'application/javascript'});
  GIF_WORKER_URL = URL.createObjectURL(blob);
  return GIF_WORKER_URL;
}
window.addEventListener('beforeunload', ()=>{ if(GIF_WORKER_URL) URL.revokeObjectURL(GIF_WORKER_URL); });

/* ========================= Export GIF (fps/dur da anim.json) ========================= */
async function exportGIFFromAnim(){
  if(!window.GIF){ alert('GIF encoder non caricato'); return; }
  if(!lottieData || !anim){ alert('Animazione non pronta'); return; }

  // 1) leggi ip/op/fr dalla lottie (manteniamo esattamente timing e numero frame)
  const fr = Number(lottieData.fr)||30;                 // fps originari
  const ip = Math.round(lottieData.ip ?? 0);            // frame start
  const op = Math.round(lottieData.op ?? anim.getDuration(true)); // frame end (non incluso)
  const N  = Math.max(1, op - ip);                      // numero frame

  // 2) prepara canva master 1800 e output 900 con micro-blur
  const master=document.createElement('canvas'); master.width=MASTER_SIZE; master.height=MASTER_SIZE;
  const mctx=master.getContext('2d');

  const out=document.createElement('canvas'); out.width=OUT_SIZE; out.height=OUT_SIZE;
  const octx = out.getContext('2d', { willReadFrequently: true });

  // 3) crea encoder GIF
  const WORKERS = Math.min(6, navigator.hardwareConcurrency || 4);
  const gif = new GIF({
	  workers: GIF_WORKERS,
	  quality: 10,                  // più veloce di 1, qualità ancora ottima
	  width: OUT_SIZE,
	  height: OUT_SIZE,
	  workerScript: await ensureGifWorkerUrl(),
	  repeat: 0,
	  dither: false,                // niente rumore
	  background: '#ffffff',        // sfondo stabile
	  transparent: null,
	  globalPalette: true           // <-- BLOCCA la palette (niente flicker)
	});



  // 4) costruiamo i delay per ogni frame (tick da ~10ms) mantenendo la durata totale
  const baseMs = 1000 / fr;
  const delays = [];
  let accMs = 0, prevQuant = 0;
  for(let i=1;i<=N;i++){
    accMs += baseMs;
    const quant = Math.max(10, Math.round(accMs/10)*10); // quantizza a 10ms
    let d = quant - prevQuant;
    if(d < 10) d = 10;  // evitare 0
    delays.push(d);
    prevQuant = quant;
  }

  // 5) UI feedback
  const btn = document.getElementById('btnExportGIF');
  const old = btn.textContent; btn.disabled = true;

  // stop preview durante export per non contendere il renderer
  previewRunning = false;

  // 6) render frame-by-frame
  for(let f=0; f<N; f++){
    const frameIndex = ip + f;
    anim.goToAndStop(frameIndex, true);
    await new Promise(r=>requestAnimationFrame(r));

    const svgBmp=await rasterizeCurrentSVG();
    drawFrameTo(mctx, MASTER_SIZE, MASTER_SIZE, svgBmp);

    // downscale con smoothing + micro-blur (toglie rumore GIF)
    octx.clearRect(0,0,OUT_SIZE,OUT_SIZE);
	octx.imageSmoothingEnabled = true;
	octx.imageSmoothingQuality = 'high';
	octx.filter = `blur(${MICRO_BLUR}px)`;  // 0.2–0.25 ok
	octx.drawImage(master, 0,0,MASTER_SIZE,MASTER_SIZE, 0,0,OUT_SIZE,OUT_SIZE);
	octx.filter = 'none';

// niente posterize / getImageData / putImageData
gif.addFrame(octx, { copy: true, delay: delays[f], dispose: 2 });


	// posterize 6-bit per stabilizzare la palette tra i frame
	const img = octx.getImageData(0,0,OUT_SIZE,OUT_SIZE);
	posterizeImageData(img);
	octx.putImageData(img, 0, 0);

	// disposal 2 = restore to background (evita accumuli)
	gif.addFrame(octx, { copy: true, delay: delays[f], dispose: 2 });

    if(f%3===0) btn.textContent = `Export GIF… ${Math.round((f+1)/N*100)}%`;
  }

  gif.on('progress', p => { btn.textContent = `Packing GIF… ${Math.round(p*100)}%`; });
  gif.on('finished', blob => {
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=`doodle_${OUT_SIZE}px_${Math.round(fr)}fps.gif`;
    a.rel='noreferrer'; a.target='_blank'; // iOS-friendly
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url),20000);
    btn.disabled=false; btn.textContent=old;
    // riattiva preview
    requestAnimationFrame(()=>{ previewRunning=false; previewLoop(); });
  });

  gif.render();
}

/* ========================= Auto-load asset (CSV, meta, anim.json) ========================= */
let META=null, COLORS=null;
function basePath(){ const u=new URL(window.location.href); u.hash=''; u.search=''; if(u.pathname.includes('/')) u.pathname=u.pathname.replace(/\/[^\/]*$/,'/'); return u.toString(); }
async function autoLoadAssets(){
  const base=basePath();
  try{ const r=await fetchWithTimeout(base+'Corrispondenze_Nome_Hex.csv',{timeout:8000,cache:'no-cache'}); COLORS=parseColorCsv(await r.text()); }
  catch{ COLORS=parseColorCsv(`Skin 1;#F5B39A
Skin 4;#E7C8A1
Yellow 1;#FFD84D
Purple 1;#C39BFF
Light Blue 1;#9BE2FF
Pink 1;#FF9BC9
Gradient 2;#95EAEC|#E6BCF9`); }

  try{ const r=await fetchWithTimeout(base+'Doodles_all_metadata.json',{timeout:8000,cache:'no-cache'}); META=await r.json(); }
  catch{ META={
    "0":{"image":"ipfs://QmUEfFfwAh4wyB5UfHCVPUxis4j4Q4kJXtm5x5p3g1fVUn","Skin_colors":"Skin 1","Sleeve_colors":"Yellow 1"},
    "1":{"image":"ipfs://QmTDxnzcvj2p3xBrKcGv1wxoyhAn2yzCQnZZ9LmFjReuH9","Skin_colors":"Gradient 2","Sleeve_colors":"Purple 1"}
  }; }

  const animResp = await fetchWithTimeout(base+'anim.json',{timeout:8000,cache:'no-cache'});
  if(!animResp.ok) throw new Error('anim.json mancante');
  await loadAnimFromJson(await animResp.json());
}

/* ========================= Compose & recolor ========================= */
function getRecord(meta,id){ const r=meta[String(id)]; if(!r) throw new Error('ID non trovato nei metadata: '+id);
  return { image:r.image, skinName:r.Skin_colors, sleeveName:r.Sleeve_colors };
}

async function composeFromId(){
  try{
    const id=Number(document.getElementById('doodleId').value);
    if(!Number.isFinite(id)) throw new Error('ID non valido');
    const rec=getRecord(META,id);
    const urls=ipfsToHttpFallbacks(rec.image);
    const resp=await fetchWithFallback(urls,{timeout:9000,mode:'cors'});
    const blob=await resp.blob();

    let bmp=null;
    try{ bmp=await createImageBitmap(blob,{colorSpaceConversion:'none',premultiplyAlpha:'default'}); }
    catch{ bmp=await new Promise((resolve,reject)=>{ const url=URL.createObjectURL(blob); const im=new Image();
      im.onload=()=>{resolve(im);URL.revokeObjectURL(url)}; im.onerror=e=>{reject(e);URL.revokeObjectURL(url)}; im.src=url; }); }

    const { fullCanvas, size_out } = await knockoutProcess(bmp,{ink:64,gap:-1,edge:18,bg_tol:24,feather:1.2,padding:24});
    doodleCanvas=fullCanvas;

    if(size_out && size_out[0]===MASTER_SIZE && size_out[1]===MASTER_SIZE){ doodleDraw={x:0,y:0,w:MASTER_SIZE,h:MASTER_SIZE}; }
    else{ const W=fullCanvas.width,H=fullCanvas.height,s=Math.min(MASTER_SIZE/W,MASTER_SIZE/H); doodleDraw={x:0,y:0,w:Math.round(W*s),h:Math.round(H*s)}; }

    // recolor overlay
    if(svgEl && COLORS){
      tagAllLayersWithNames(anim);
      const skinStops=COLORS.getStops(rec.skinName), sleeveStops=COLORS.getStops(rec.sleeveName);
      (skinStops.length===1?setLayerFlatByName:setLayerGradientStopsByName)(svgEl,LAYER_SKIN,skinStops,'horizontal');
      (sleeveStops.length===1?setLayerFlatByName:setLayerGradientStopsByName)(svgEl,LAYER_SLEEVE,sleeveStops,'horizontal');
      setSoftLightByName(svgEl,LAYER_SHADOW,0.8);
    }

    // preview a fps originali (clamp 60)
    const fr = Math.min(60, Math.max(1, Math.round(lottieData?.fr || 30)));
    previewFps = fr;
    sizeViewer(OUT_SIZE);
    previewRunning=false;
    requestAnimationFrame(()=>previewLoop());
  }catch(err){ console.error(err); alert('Errore: '+(err.message||String(err))); }
}

/* ========================= Init ========================= */
function init(){
  sizeViewer(OUT_SIZE);
  autoLoadAssets().catch(e=>{ console.error(e); alert('Errore caricamento asset: '+e.message); });
  document.getElementById('btnCompose').onclick=composeFromId;
  document.getElementById('btnExportGIF').onclick=exportGIFFromAnim;
}
init();
</script>
</body>
</html>
